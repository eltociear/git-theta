#!/usr/bin/env python

import argparse
import os
import sys
import git
import logging

from scipy import sparse
from git_theta import git_utils, checkpoints, file_io, utils, constants, params

logging.basicConfig(
    level=logging.DEBUG, format="git-theta: [%(asctime)s] %(levelname)s - %(message)s"
)


def parse_args():
    parser = argparse.ArgumentParser(description="git-theta filter program")
    subparsers = parser.add_subparsers(title="Commands", dest="command")
    subparsers.required = True

    add_parser = subparsers.add_parser(
        "add", help="add command used to stage a model file"
    )
    add_parser.add_argument("file", help="file being staged")
    add_parser.add_argument("--update_type", choices=["dense", "sparse", "lr"], default="dense")
    add_parser.set_defaults(func=add)

    install_parser = subparsers.add_parser(
        "install", help="install command used to setup global .gitconfig"
    )
    install_parser.set_defaults(func=install)

    track_parser = subparsers.add_parser(
        "track",
        help="track command used to identify model checkpoint for git-theta to track",
    )
    track_parser.add_argument(
        "file", help="model checkpoint file or file pattern to track"
    )
    track_parser.set_defaults(func=track)

    args = parser.parse_args()
    return args


def iterate_dict_and_dir_leaves(d, root):
    """
    Generator that iterates through dictionary leaves and produces (param, param_file) tuples where param is a dictionary leaf
    and param_file is the file below root corresponding to the sequence of keys used to access the dictionary leaf. Each subdirectory
    between root and param_file is created if it does not exist.

    Example
    -------
    d = {'a': {'b': {'c': 10, 'd': 20, 'e': 30}}}
    root = 'rootdir'
    iterate_dict_and_dir_leaves(d, root) --> ((10, 'rootdir/a/b/c'), (20, 'rootdir/a/b/d'), (30, 'rootdir/a/b/e'))

    Parameters
    ----------
    d : dict
        dictionary to iterate over
    root : str
        path to root directory where directory tree representing `d` is created
    """
    for leaf, keys in checkpoints.iterate_dict_leaves(d):
        param_dir = os.path.join(root, "/".join(keys))
        if not os.path.exists(param_dir):
            os.makedirs(param_dir)
        yield leaf, param_dir


def iterate_removed_params(d, root):
    """
    Generator that iterates a model directory and yields the parameter groups that are present in the model directory but not in the model dictionary

    Example
    -------

    Parameters
    ----------
    """
    for leaf, keys in checkpoints.iterate_dir_leaves(root):
        curr_d = d
        for k in keys:
            if curr_d.get(k) is None:
                yield leaf
                continue
            curr_d = curr_d[k]


def add(args):
    """
    Splits model parameters file into parameter groups on filesystem and stages files
    """
    repo = git_utils.get_git_repo()
    model_path = git_utils.get_relative_path_from_root(repo, args.file)
    theta_model_dir = git_utils.get_git_theta_model_dir(repo, model_path, create=True)

    param_dict = checkpoints.PyTorchCheckpoint.from_file(args.file)

    # Check if sparse update
    if(args.update_type == constants.DENSE_UPDATE):
        for (param, param_dir) in iterate_dict_and_dir_leaves(param_dict, theta_model_dir):
            param_file = os.path.join(param_dir, constants.THETA_PARAMS_FOLDER)
            file_io.write_tracked_file(param_file, param)
            git_utils.add_file(param_file, repo)

        # Delete contents of updates folder
        updates_dir = os.path.join(param_dir, constants.THETA_UPDATES_FOLDER)
        if(os.path.exists(updates_dir)):
            for update_file in os.listdir(updates_dir):
                logging.info(f"Removing file {update_file} from {updates_dir}")
                git_utils.remove_file(os.path.join(updates_dir, update_file), repo)

    elif(args.update_type == constants.SPARSE_UPDATE):
        prev_param_dict = utils.get_prev_param_dict(theta_model_dir)
        sparse_diff_dict = utils.get_sparse_diff(prev_param_dict, param_dict)
        # write to updates folder
        if(sparse_diff_dict):
            for param_name, param in sparse_diff_dict.items():
                # Get parameter hash
                file_name = params.get_hash(sparse_diff_dict[param_name].todense()) + '.npz'
                updates_dir = os.path.join(theta_model_dir, param_name, constants.THETA_UPDATES_FOLDER)
                param_file = os.path.join(updates_dir, file_name)
                logging.debug(f"Writing {param_name} updates to {param_file}")
                # file_io.write_tracked_file(param_file, param)
                os.makedirs(updates_dir, exist_ok=True)
                sparse.save_npz(param_file, param)

                # append to metadata file
                logging.info(f"Appending update file entry {file_name} to metadata file")
                metadata_file = os.path.join(updates_dir, constants.THETA_UPDATES_METADATA_FILE)
                with open(metadata_file, 'a+') as f:
                    f.write(f"{file_name},{constants.SPARSE_UPDATE}\n")

                git_utils.add_file(param_file, repo)
                git_utils.add_file(metadata_file, repo)
    else:
        logging.info("Low Rank not implemented")

    # Remove param groups not present in model from theta_model_dir
    for param_file in iterate_removed_params(param_dict, theta_model_dir):
        git_utils.remove_file(param_file, repo)

    git_utils.add_file(model_path, repo)


def install(args):
    """
    Install git-lfs and initialize the git-theta filter driver
    """
    git_utils.git_lfs_install()
    config_writer = git.GitConfigParser(
        git.config.get_config_path("global"), config_level="global", read_only=False
    )
    config_writer.remove_option('filter "lfs"', "process")
    config_writer.set_value('filter "theta"', "clean", "git-theta-filter clean %f")
    config_writer.set_value('filter "theta"', "smudge", "git-theta-filter smudge %f")
    config_writer.set_value('filter "theta"', "required", "true")
    config_writer.release()


def track(args):
    """
    Track a particular model checkpoint file with git-theta
    """
    repo = git_utils.get_git_repo()
    model_path = git_utils.get_relative_path_from_root(repo, args.file)

    # Initialize git lfs to track model files in .git_theta
    theta_model_dir = git_utils.get_git_theta_model_dir(repo, model_path)
    git_utils.git_lfs_track(repo, theta_model_dir)

    gitattributes_file = git_utils.get_gitattributes_file(repo)
    gitattributes = git_utils.read_gitattributes(gitattributes_file)

    new_gitattributes = git_utils.add_filter_theta_to_gitattributes(gitattributes, model_path)

    git_utils.write_gitattributes(gitattributes_file, new_gitattributes)
    git_utils.add_file(gitattributes_file, repo)


if __name__ == "__main__":
    args = parse_args()
    args.func(args)
